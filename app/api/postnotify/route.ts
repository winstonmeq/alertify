import { PrismaClient } from "@prisma/client";
import { NextResponse, NextRequest } from "next/server";
import admin from "firebase-admin";
import { RateLimiterMemory, RateLimiterRes } from 'rate-limiter-flexible'; // For rate limiting
import asyncBatch from 'async-batch'; // For batch processing FCM notifications




const prisma = new PrismaClient();
const VERIFY_TOKEN = "mySecretAlertifyToken2025";

// Define the Emergency type based on your Prisma schema
interface Emergency {
  id?: string; // Optional since itâ€™s auto-generated by Prisma
  emergency: string;
  lat: string;
  long: string;
  barangay: string;
  munName: string;
  name: string;
  mobile: string;
  munId: string;
  provId: string;
  photoURL: string;
  mobUserId: string; // Assuming this is a string based on your schema
  createdAt?: Date; // Optional, added by Prisma
}


// Rate limiter configuration
const rateLimiter = new RateLimiterMemory({
  points: 100, // Max 100 requests
  duration: 60, // Per 60 seconds per IP
});



if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert({
      projectId: process.env.FIREBASE2_PROJECT_ID,
      privateKey: process.env.FIREBASE2_PRIVATE_KEY?.replace(/\\n/g, "\n"),
      clientEmail: process.env.FIREBASE2_CLIENT_EMAIL,
    }),
  });
}




async function sendFcmNotification(data: Emergency, fcmMobileToken: string): Promise<void | Error> {
  const { name, emergency } = data;
  try {
    await admin.messaging().send({
      notification: {
        title: "Incident Report!",
        body: `${name} reported a ${emergency} incident!.`,
      },
      token: fcmMobileToken,
    });
    console.log("FCM notification sent successfully");
  } catch (error) {
    console.error("Failed to send FCM notification:", error);
    return error instanceof Error ? error : new Error(String(error));
  }
}


export async function POST(request: Request) {

    const clientIp = request.headers.get('x-forwarded-for') || 'unknown';



  try {

    await rateLimiter.consume(clientIp);

    
  const { searchParams } = new URL(request.url);
  const token = searchParams.get("token");


  if (token !== VERIFY_TOKEN) {
    return new NextResponse("Verification failed", { status: 403 });
  }
  
    
    const requestBody = await request.json();
    const { emergency, lat, long, barangay,munName, name, mobile, photoURL, situation, mobUserId, munId, provId } =  requestBody;

    if (!emergency || !lat || !long || !barangay || !name || !mobile) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }


    
    const savedData = await prisma.postnotify.create({
      data: { emergency, lat, long, barangay, munName, name, mobile, verified: true, photoURL, situation, munId, provId,  mobUserId }
    });

    
    console.log('this is provId', provId);

      // Fetch FCM tokens
    const fcmTokens = await prisma.fcmmobile.findMany({
      where: { provId: provId, isActive: true }, // Filter by provId
      select: { fcmToken: true }, // Select only fcmToken to reduce data transfer
    });
    
      console.log('getToken result:', fcmTokens);
    
        if (fcmTokens.length === 0) {
          console.warn('No FCM Mobile tokens found for the specified provId:', provId);
          return NextResponse.json({ error: 'No FCM tokens found for the specified municipality' }, { status: 404 });
        }
    

        // Batch process FCM notifications
    await asyncBatch(
      fcmTokens.filter(token => token.fcmToken), // Filter out invalid tokens
      async (token) => {
        try {
          await sendFcmNotification(savedData, token.fcmToken);
        } catch (error) {
          console.warn('FCM notification failed', { fcmToken: token.fcmToken, error });
        }
      },
      10 // Process 10 notifications concurrently
    );


    return NextResponse.json(
      { message: "Postnotify data saved successfully" },
      { status: 201 }
    );

    
  } catch (error) {
    console.error("Error during saving data:", error);
    // return NextResponse.json({ message: "Failed to save data" }, { status: 500 });

    if (error instanceof RateLimiterRes) {
      console.warn('Rate limit exceeded', { clientIp });
      return NextResponse.json({ error: 'Too many requests' }, { status: 429 });
    }

    console.warn('Error processing request', { error, clientIp });
    return NextResponse.json({ error: 'Failed to save data' }, { status: 500 });

  } finally {

  }
}






export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1', 30);
  const limit = 30;
  const skip = (page - 1) * limit;
  // const todayDate = searchParams.get("createdAt") || undefined; // Get provId from query params, default to undefined if not provided
 const munId = searchParams.get("munId") || undefined; // Get munId from query params, default to undefined if not provided
  const provId = searchParams.get("provId") || undefined; // Get provId from query params, default to undefined if not provided


  try {
    const emergency_data = await prisma.postnotify.findMany({

      where: {
        ...(provId && { provId }),
         ...(munId && { munId }), 
      },

      skip,
      take: limit,
      orderBy: {
        createdAt: 'desc',
      },
    });

    const totalRecords = await prisma.postnotify.count();

    const response = NextResponse.json({ emergency_data, totalRecords });


    return response;
  } catch (error) {
    console.error("Error fetching emergency data:", error);
    return NextResponse.error();
  }
}




